## bloom

### 模块概要

`util/hash.h`

``util/hash.cc`

`leveldb/filter_policy.h`

`util/bloom.cc`

### 模块接口

```c++
CreateFilter(const Slice* keys, int n,std::string* dst)//向dst存储keys数组中所有的key。
bool KeyMayMatch(const Slice& key, const Slice& filter)//如果key存在的话返回true，不存在的话true和false都有可能返回
```

### 模块实现

### hash

对于一个字符串hash时每四位一次压成一个uint32_t然后进行哈希。和murmur hash相似(这个名字好可爱··)。

#### Bloom Filter

```c++
  bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const override {
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len - 1];//k指每个数据的占的位数。
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }

    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // 高17位变成低17位低15位变为高15位。shuffle一下
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;//等于k次hash
    }
    return true;
  }
```



### 相关语法



### reference

https://blog.csdn.net/jiaomeng/article/details/1495500

[bloom证明相关 ](https://blog.csdn.net/jiaomeng/article/details/1495500)

