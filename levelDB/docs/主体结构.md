## 主体结构

![结构图](pic\主体结构_structure.jpg)



###1.读写基本流程

![img](pic\主体结构_读写基本流程.jpg)

* 读数据

  1.依次查找memtable immutable

  2.如果有cache，查找cache。

  3.根据mainfest索引先查找log然后按照level查找SST。

* 写数据

  1.写入log文件

  2.写入内存中的memtable(skeplist)。

  3.写入磁盘的SST文件(sorted string table files)。

### 2. 内存-memtable+immutable memtable

* memtable 和immutable memtable的结构是一样的只是可读写和只读的区别。

- 在写memtable时，如果其达到checkpoint的话，会将其改成只读的immutable memtable，然后等待dump到磁盘SST文件中，此时也会生成新的memtable供写入新数据；
- memtable使用**SkipList** 进行实现。
- memtable和sst文件中的key都是有序的，log文件的key是无序的。

### 3.硬盘-log文件

写入数据时，最开始会将数据写入到硬盘log文件中然后再写入到内存的memtable 。

Log：最大4MB (可配置)

![记录结构](pic\主体结构_record.png)

每次更新写入为一个record，上图是record的结构。`checksum`对type和data部分进行校验。`lenghth`记录data的长度（小端对齐）。`type`记录record在block中的完整性，可以是`FULL`, `FIRST`, `MIDDLE`, `LAST`。

levelDB将log文件切分为每个大小为32KB的block，block是每次读取的单位。下图是三条record存储在三个block中的结构。

![log文件布局](pic\主体结构_log文件布局.png)



### 4. 硬盘-manifest文件和current文件

manifest文件管理每个SSTable所存储的key信息。leve信息，文件名，最小key和最大key。

![img](pic\主体结构_manifest.png)

在compaction进行过程中SSTable文件会发生变化会新生成manifest的文件进行记载，current文件就是用来记载当前使用的manifest文件名信息。

###5 .硬盘-SSTable 文件

LevelDB 不同层级有很多 SSTable 文件（以后缀.sst为特征）下图展示了一个 .sst 文件的物理划分结构，同 log 文件一样，也是划分为固定大小的存储块.

每个 Block 分为四个部分：

* `数据存储区(entry)` :key-value键值对存储。

* `Tailer` :包括restart数组和一个num(restart数组长度)其实是一些指针，指出 Block 内容中的一些记录位置。

重启点（restart）是干什么的呢？Block内容里的KV记录是按照 key 大小有序的，这样的话，相邻的两条记录很可能 key 部分存在重叠，比如 key i=“the Car”，Key i+1=“the color”，那么两者存在重叠部分 “the c”，为了减少 key 的存储量，Key i+1 可以只存储和上一条 key 不同的部分 “olor”，两者的共同部分从 key i 中可以获得。记录的 key 在 Block 内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的 key 部分，而是重新记录所有的 key 值，假设 key i+1 是一个重启点，那么 key 里面会完整存储 “the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。

![记录格式](pic\主体结构_records_.png)

​																					record 格式

`Type` 用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩），

`CRC校验` 数据校验码，用于判别数据在生成和传输中是否出错。

![clipboard.png](pic\主体结构_物理.jpg)



下图是.sst文件中的数据块的逻辑布局，分为数据存储区和数据管理区。数据管理区又分为

* `meta block`：每个datablock对应一个metablock。比较特殊的Block，用来存储元信息，目前LevelDB使用的仅有对bloom过滤器的存储。写入Data Block的数据会同时更新对应Meta Block中的过滤器。读取数据时也会首先经过`bloom过滤器过滤`.
  * `bloom过滤器`：使用hash判断key是否存在。

* `metablockindex`：目前只有bloom->meta_Data的地址

* `index block`：每个datablock最后一个key+此地址。查找先在bloom（从内存的filemetadata只能判断范围，但是稀疏存储，不知道是否有值）中判断有再从data index中二分查找（到重启点比较）再从data block中二分查找

* `footer`：文件末尾固定长度的数据。保存着 `metaindex_block `和 `index_block `的索引信息(BlockHandler)(起始位置和大小)，为达到固定的长度，添加`padding_bytes`。最后有8个字节的 `magic `校验。

![Footer](pic\主体结构_footer.png)

![clipboard.png](pic\主体结构_逻辑.jpg)

### 8. Compaction

LevelDB 包含其中两种 compaction 模式：minor 和 major。

#### 8.1minor compaction

 memtable 中的数据导出到 SSTable 文件。

遍历immutable memtable 的key并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 。

对于被删除的记录，在 minor compaction 过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉 key 记录，但是这个 KV 数据在哪里？那需要复杂的查找，所以在 minor compaction 的时候并不做删除，只是将这个 key 作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的 compaction 中会去做。

![img](pic\主体结构_minor_com.png)



#### 8.2 major compaction

合并不同层级的 SSTable 文件。

对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。

![SSTable compaction](pic\主体结构_majpr_comp.png)

###9.cache

LevelDB 中引入了两个不同的 Cache:Table Cache 和 Block Cache。其中 Block Cache 是配置可选的，即在配置文件中指定是否打开这个功能。

#### 9.1 table cache

比如在 get(key) 读取操作中，如果 LevelDB 确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，LevelDB 会首先查找 Table Cache，看这个文件是否在缓存里，如果找到了，那么根据table index 部分就可以查找是哪个 block 包含这个 key。如果没有在缓存中找到文件，那么打开 SSTable 文件，将其 index 部分读入内存，然后插入 Cache 里面。这样可以减少一次读取index。

![img](pic\主体结构_tablecache.png)

#### 9.2block cache 

如果 LevelDB发现这个 block 在 block cache 中，那么可以避免读取数据，直接在 cache 里的 block 内容里面查找key的value就行，如果没找到呢？那么读入 block 内容并把它插入 block cache 中。LevelDB 就是这样通过两个 cache 来加快读取速度的。

![SSTable compaction](pic\主体结构_block_cache.png)



### 10.version

**Version** 保存了当前磁盘以及内存中所有的文件信息，一般只有一个 Version 叫做 “current” version（当前版本）。LevelDB还保存了一系列的历史版本，这些历史版本有什么作用呢？

当一个 Iterator 创建后，Iterator 就引用到了 current version(当前版本)，只要这个 Iterator 不被 delete 那么被 Iterator 引用的版本就会一直存活。这就意味着当你用完一个 Iterator 后，需要及时删除它。

当一次 Compaction 结束后（会生成新的文件，合并前的文件需要删除），LevelDB 会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。

**VersionSet** 是所有 Version的集合，管理着所有存活的 Version。

**VersionEdit** 表示 Version 之间的变化，相当于 delta 增量，表示有增加了多少文件，删除了文件。VersionEdit 会保存到 manifest 文件中，当做数据恢复时就会从 manifest 文件中读出来重建数据。

### reference 

* [LevelDB 源码分析（二）：主体结构](http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/)

* [levelDB总结](https://blog.csdn.net/poi7777/article/details/49124491)
* [LevelDB详解](https://blog.csdn.net/linuxheik/article/details/52768223)